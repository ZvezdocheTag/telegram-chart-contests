"use strict";

function _instanceof(left, right) { if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) { return right[Symbol.hasInstance](left); } else { return left instanceof right; } }

function _classCallCheck(instance, Constructor) { if (!_instanceof(instance, Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _toArray(arr) { return _arrayWithHoles(arr) || _iterableToArray(arr) || _nonIterableRest(); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

(function () {
  // CONSTANTS
  var colorTheme = window.colorTheme;
  var MONTHES = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
  var MONTHES_FULL = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];
  var DAYS = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'];
  var CANVAS_COLOR_TYPES_FOLLOWERS = 'followers';
  var CANVAS_COLOR_TYPE_APPS = 'apps';
  var CANVAS_COLOR_TYPE_ONLINES = 'onlines';
  var LAYOUT_MODE_DAY = 'day';
  var LAYOUT_MODE_NIGHT = 'night';
  var layoutColorMode = LAYOUT_MODE_DAY;
  var getDataFormat = {
    'id_1': {
      link: '/data/1/overview.json',
      colorScheme: CANVAS_COLOR_TYPES_FOLLOWERS,
      title: 'Followers',
      id: 'id_1'
    },
    'id_2': {
      link: '/data/2/overview.json',
      colorScheme: CANVAS_COLOR_TYPES_FOLLOWERS,
      title: 'Interactions',
      id: 'id_2'
    },
    'id_3': {
      link: '/data/3/overview.json',
      colorScheme: CANVAS_COLOR_TYPE_APPS,
      title: 'Messages',
      id: 'id_3'
    },
    'id_4': {
      link: '/data/4/overview.json',
      colorScheme: CANVAS_COLOR_TYPE_ONLINES,
      title: 'Views',
      id: 'id_4'
    },
    'id_5': {
      link: '/data/5/overview.json',
      colorScheme: CANVAS_COLOR_TYPE_APPS,
      title: 'Apps',
      id: 'id_5'
    }
  };
  var chart = {
    state: {},
    init: function init() {
      var main = qs('main');
      main.style.width = window.innerWidth;
      var dataReq = Object.values(getDataFormat);

      var _loop = function _loop() {
        var d = _dataReq[_i];
        fetch(d.link).then(function (res) {
          return res.json();
        }).then(function (data) {
          ChartRoot.init(d.id, main, normilizeData(data), d.title, d.colorScheme);
        }).catch(function (err) {
          throw err;
        });
      };

      for (var _i = 0, _dataReq = dataReq; _i < _dataReq.length; _i++) {
        _loop();
      }

      qs('.toggle-mode-btn').addEventListener('click', function () {
        document.body.classList.toggle('dark');
        layoutColorMode = layoutColorMode === 'day' ? LAYOUT_MODE_NIGHT : LAYOUT_MODE_DAY;
        ChartRoot.setStyleMode(colorTheme[layoutColorMode]);
      });
    }
  };
  var Axis = {
    render: function render(axisWrapper, ticks, axis, width) {
      var tickWrapper = createTick(axisWrapper, axis, width);
      ticks.forEach(function (item) {
        var tick = item.tick;
        var tickEl = tickWrapper.cloneNode(true);
        tickEl.children[0].textContent = tick;
        var transform = axis === 'x' ? "translate(".concat(item[axis], ", 0)") : "translate(0, ".concat(item[axis], ")");
        setAttrNs(tickEl, [{
          transform: transform
        }]);
        axisWrapper.appendChild(tickEl);
      });
    },
    update: function update(svg, ticks, axis) {
      if (!ticks) {
        // svg.style.opacity = 0
        return;
      } // svg.style.opacity = 1


      var curr = svg.querySelectorAll(".tick-".concat(axis));
      ticks.forEach(function (tick, idx) {
        var transform = axis === 'x' ? "translate(".concat(tick[axis], ", 0)") : "translate(0, ".concat(tick[axis], ")");
        setAttrNs(curr[idx], [{
          transform: transform
        }]);
        curr[idx].children[0].textContent = tick.tick;
      });
    }
  };

  function getDataRangeToString(coords) {
    var _coords$0$currentRang = coords[0].currentRangeData.slice(0, 1),
        _coords$0$currentRang2 = _slicedToArray(_coords$0$currentRang, 1),
        getCurrentRangesFirst = _coords$0$currentRang2[0];

    var _coords$0$currentRang3 = coords[0].currentRangeData.slice(-1),
        _coords$0$currentRang4 = _slicedToArray(_coords$0$currentRang3, 1),
        getCurrentRangesLast = _coords$0$currentRang4[0];

    var from = getFullDate(getCurrentRangesFirst.value, true);
    var to = getFullDate(getCurrentRangesLast.value, true);
    return "".concat(from, " - ").concat(to);
  }

  var ChartRoot = {
    state: {
      chart: {},
      ineracted: {},
      mouseEvents: {
        chart: null,
        minimap: null
      },
      ranges: {},
      calculation: {},
      tooltipPos: {
        x: 0,
        left: 0
      },
      colorsPallet: null,
      rangesList: {}
    },
    setStyleMode: function setStyleMode(params) {
      Object.values(this.state.chart).forEach(function (item) {
        var controls = item.querySelector('.chart-contols').children;
        var currentTheme = item.dataset.colorTheme;

        for (var i = 0; i < controls.length; i += 1) {
          setupDefaultButtonColor(controls[i], params[currentTheme][controls[i].innerText].btn);
        }
      });
    },
    init: function init(id, main, data, title, colorType) {
      var _this2 = this;

      var w = main.offsetWidth - 20;
      var h = 250;
      var mH = 55;
      var idAttr = "_".concat(id);
      var y_scaled = false;
      var stacked = false;
      var percentage = false;

      if (data.y_scaled) {
        y_scaled = true;
      }

      if (data.stacked) {
        stacked = true;
      }

      if (data.percentage) {
        percentage = true;
      }

      Object.entries(data.names).forEach(function (_ref) {
        var _ref2 = _slicedToArray(_ref, 2),
            key = _ref2[0],
            name = _ref2[1];

        if (!_this2.state.ineracted[idAttr]) {
          _this2.state.ineracted[idAttr] = {};
        }

        _this2.state.ineracted[idAttr][key] = {
          name: name,
          active: false
        };
      });
      var initialRange = [0, 100];
      var interacted = this.state.ineracted[idAttr];
      var colr = colorTheme[layoutColorMode][colorType];
      this.state.ranges[idAttr] = initialRange;
      var initialProcess = processCoords(w, h, initialRange, data);
      var chartTypes = initialProcess.types;
      var coords = initialProcess.data;
      this.state.calculation[idAttr] = coords;
      var coordInitialMinimap = processCoords(w, mH, null, data, interacted).data;
      console.log(initialProcess, 'FFFFFFFFF ');
      var template = ChartTemplate(idAttr, data, {
        w: w,
        h: h,
        mW: w,
        mH: mH,
        colors: colorType,
        pallet: colr,
        title: title
      });
      main.insertAdjacentHTML('beforeEnd', template);
      var wrapper = qs("#".concat(idAttr));
      var controls = wrapper.querySelector('.chart-contols');
      var chart = wrapper.querySelector('.chart');
      this.state.chart[idAttr] = wrapper;
      var chartMinimap = wrapper.querySelector('.minimap-chart');
      var chartMagnifier = wrapper.querySelector('.magnifier');
      var svgAxis = wrapper.querySelector('.chart-axises');
      var svgAxisX = wrapper.querySelector('.chart-axises-x');
      var wrappersX = svgAxisX.querySelector(".tick-wrapper-x");
      var wrappersY = svgAxis.querySelector(".tick-wrapper-y");
      var wrappersYAll = svgAxis.querySelectorAll(".tick-wrapper-y");
      var svg = chart.getContext('2d');
      var svgMinimap = chartMinimap.getContext('2d');
      var chartHeaderDates = qs(".chart-header.".concat(idAttr, " .dates-range"));
      chartHeaderDates.textContent = getDataRangeToString(coords);

      if (idAttr !== '_id_4') {
        Object.entries(data.names).forEach(function (_ref3) {
          var _ref4 = _slicedToArray(_ref3, 2),
              key = _ref4[0],
              name = _ref4[1];

          controls.insertAdjacentHTML('beforeEnd', Button(key, name, colr[name].btn));
        });
      }

      var resizeFunc = actionResize.bind(this);
      var setupResize = resizeFunc(svg, w, h, data, wrappersYAll, wrappersX, y_scaled);
      document.addEventListener('transitionend', function (event) {
        wrappersY.classList.remove('is-moved-up');
      });

      function actionResize(svg, w, h, data, svgAxisY, svgAxisX, y_scaled) {
        var self = this;
        return {
          update: function update(min, max, status) {
            if (!wrappersY.classList.contains('is-moved-up')) {
              wrappersY.classList.add('is-moved-up');
            }

            self.state.ranges[idAttr] = [min, max];
            var initialProcess = processCoords(w, h, [min, max], data, status);
            var initialProcessMin = processCoords(w, mH, null, data, status);
            var coords = initialProcess.data;
            self.state.rangesList[idAttr] = coords[0].currentRangeData;
            console.log(coords);
            svg.clearRect(0, 0, w, h);
            svgMinimap.clearRect(0, 0, w, mH);
            renderLine(svg, coords, h, w);
            renderLine(svgMinimap, initialProcessMin.data, mH, w);
            Axis.update(svgAxisX, initialProcess.horizontal, 'x');
            chartHeaderDates.textContent = getDataRangeToString(coords);
            svgAxisY.forEach(function (item) {
              var yCurrentData = y_scaled ? initialProcess.vertical[item.dataset.axisKey] : initialProcess.commonY;
              Axis.update(item, yCurrentData, 'y', w);
            }); // Tooltip(svgAxis, colr, chartTypes)
          }
        };
      } // Create variable for setTimeout


      var delay; // Set number of milliseconds for longpress

      var longpress = 1300;
      controls.childNodes.forEach(function (child) {
        var self = _this2;
        child.addEventListener('touchstart', function (e) {
          console.log(e);

          var _this = this;

          delay = setTimeout(check, longpress);

          function check() {
            // var i = 0
            console.log(controls);

            for (var i = 0; i < controls.children.length; i += 1) {
              var childOther = controls.children[i];
              var color = childOther.dataset.color;

              if (!_this.isSameNode(childOther)) {
                childOther.classList.add('active');
                childOther.style.backgroundColor = 'transparent';
                childOther.style.color = "#".concat(color);
                childOther.style.borderColor = "#".concat(color);
              }
            }
          }
        }, true);
        child.addEventListener('touchend', function (e) {
          // On mouse up, we know it is no longer a longpress
          console.log(e);
          clearTimeout(delay);
        }); // child.addEventListener('mouseout', function (e) {
        //   clearTimeout(delay);
        // });

        child.addEventListener('click', function (e) {
          e.preventDefault();
          console.log(e, 'CLICK');
          var target = e.target;
          var color = target.dataset.color;
          var btnId = target.dataset.toggleBtn;
          target.classList.toggle('active');

          var _self$state$ranges$id = _slicedToArray(self.state.ranges[idAttr], 2),
              min = _self$state$ranges$id[0],
              max = _self$state$ranges$id[1];

          var isActive = target.classList.value.includes('active');
          var currBtn = interacted[btnId];
          currBtn.active = isActive;
          setupResize.update(min, max, interacted);

          if (isActive) {
            target.style.backgroundColor = 'transparent';
            target.style.color = "#".concat(color);
            target.style.borderColor = "#".concat(color);
          } else {
            setupDefaultButtonColor(target, color);
          }
        });
      });
      renderLine(svg, coords, h, w);
      renderLine(svgMinimap, coordInitialMinimap, mH, w);
      wrappersYAll.forEach(function (item) {
        var yCurrentData = y_scaled ? initialProcess.vertical[item.dataset.axisKey] : initialProcess.commonY;
        Axis.render(item, yCurrentData, 'y', w);
      });
      Axis.render(wrappersX, initialProcess.horizontal, 'x', w);
      Tooltip(svgAxis, colr, chartTypes);
      new Magnifier(chartMagnifier, setupResize, interacted, initialRange).init();
      var self = this;

      function Tooltip(svg, colr, chartTypes) {
        var line = null;
        var currentChart = null;
        var getFirstRange = null;
        var tooltip = document.querySelector('.chart-tooltip');
        var dataId = svg.closest('.chart-wrapper').id;
        var containerWidth = svg.clientWidth;
        svg.addEventListener('mouseenter', enterMouse, {
          passive: true
        });
        svg.addEventListener('touchstart', enterMouse, {
          passive: true
        });
        svg.addEventListener('mousemove', moveMouse, {
          passive: true
        });
        svg.addEventListener('touchmove', moveMouse, {
          passive: true
        });
        svg.addEventListener('mouseleave', mouseLeave);
        svg.addEventListener('touchend', mouseLeave);

        function enterMouse(e) {
          currentChart = self.state.calculation[dataId];
          getFirstRange = self.state.rangesList[dataId];
          console.log(getFirstRange);
          tooltip.insertAdjacentHTML('beforeend', '<ul class="tooltip-list"></ul>');
          var list = tooltip.querySelector('.tooltip-list');
          currentChart.reverse().forEach(function (line, idx) {
            var html = "<li data-key=\"".concat(line.key, "\">\n            <div class=\"tooltip-item-name\">").concat(line.name, "</div>\n            <div class=\"tooltip-item-value\" style=\"color: #").concat(colr[line.name].tooltipText, ";\">").concat(line.valueX, "</div>\n          </li>"); // console.log(chartTypes)

            if (chartTypes === 'line') {
              var dot = document.createElementNS('http://www.w3.org/2000/svg', "circle");
              setAttrNs(dot, [{
                class: 'svg-line-points'
              }, {
                'data-key': line.key
              }, {
                cx: 0
              }, {
                r: 4
              }, {
                opacity: 0
              }, {
                cy: 0
              }, {
                stroke: "".concat(line.color)
              }, {
                fill: "transparent"
              }, {
                'stroke-width': "3"
              }]);
              svg.insertAdjacentElement('beforeend', dot);
            }

            list.insertAdjacentHTML('beforeend', html);
          });
          line = e.target.querySelector('.tooltip-line');
          line.style.opacity = "1";

          if (!tooltip.classList.contains('active')) {
            tooltip.classList.add('active');
          }
        }

        function moveMouse(e) {
          var offsetX = e.offsetX;
          var pageX = e.pageX;
          var pageY = e.pageY;

          if (e.type === 'touchmove') {
            pageX = e.touches[0].pageX;
            pageY = e.touches[0].pageY;
            offsetX = pageX;
          }

          var _getFirstRange$filter = getFirstRange.filter(function (item) {
            return item.x < offsetX;
          }).slice(-1),
              _getFirstRange$filter2 = _slicedToArray(_getFirstRange$filter, 1),
              currentTooltipPos = _getFirstRange$filter2[0];

          var currentCoords = null;

          if (currentTooltipPos) {
            currentCoords = findHoveredCoordinates(currentChart, currentTooltipPos.idx);
          }

          if (currentCoords) {
            rerenderTooltip(currentCoords);

            if (chartTypes === 'line') {
              currentCoords.forEach(function (item) {
                var point = svg.querySelector("circle[data-key=".concat(item.key, "]"));
                setAttrNs(point, [{
                  cx: item.x + 8
                }, {
                  cy: item.y.y
                }, {
                  opacity: 1
                }]);
              });
            }
          }

          var tooltipWidth = tooltip.clientWidth;
          var top = pageY - 10;
          var left = pageX + 30;
          var coordLeft = tooltipWidth + offsetX + 30;
          tooltip.style.top = top + 'px';

          if (coordLeft > containerWidth) {
            tooltip.style.left = pageX - tooltipWidth - 30 + 'px';
          } else {
            tooltip.style.left = left + 'px';
          }

          line.style.transform = "translate(".concat(offsetX, "px, 0)");
        }

        function rerenderTooltip(items) {
          var keyTime = new Date();

          if (items[0]) {
            keyTime = items[0].value;
            var date = getFullDate(keyTime);

            var _title = tooltip.querySelector('.tooltip-title');

            var list = tooltip.querySelector('.tooltip-list');
            _title.textContent = date;
            items.forEach(function (item) {
              var curr = list.querySelector("[data-key=".concat(item.key, "]"));
              curr.querySelector('.tooltip-item-value').textContent = item.valueY;
            });
          }
        }

        function findHoveredCoordinates(coordinates, hoveredIdx) {
          var currentHovered = [];
          coordinates.forEach(function (item) {
            currentHovered.push(item.currentRangeData[hoveredIdx]);
          });
          return currentHovered;
        }

        function mouseLeave(e) {
          line = null;
          var list = tooltip.querySelector('.tooltip-list');
          list.remove();

          if (tooltip.classList.contains('active')) {
            tooltip.classList.remove('active');
          }
        }
      }
    }
  };

  function renderLine(ctx, coords, height, w, stacked) {
    ctx.save();
    coords.forEach(function (_ref5) {
      var key = _ref5.key,
          points = _ref5.points,
          color = _ref5.color,
          types = _ref5.types,
          currentRangeData = _ref5.currentRangeData;
      var diffWidth = Math.ceil(w / currentRangeData.length);

      if (types === 'line') {
        drawLine(ctx, points, color, height);
      }

      if (types === 'bar') {
        barRect(ctx, points, color, height, diffWidth);
      }

      if (types === 'area') {
        drawArea(ctx, points, color, height);
      }
    });
    ctx.restore();
  }

  function calculateChartRanges(_ref6, status) {
    var names = _ref6.names,
        types = _ref6.types,
        columns = _ref6.columns,
        colors = _ref6.colors,
        percentage = _ref6.percentage,
        stacked = _ref6.stacked;
    var uniqNames = Object.keys(names);

    if (status) {
      uniqNames = uniqNames.filter(function (nm) {
        return !status[nm].active;
      });
    }

    var res = uniqNames.map(function (key) {
      var $X = 'x';
      return {
        color: colors[key],
        x: columns[$X],
        y: columns[key],
        yDefault: columns[key],
        key: key,
        name: names[key],
        xRange: getRangeMinMax(columns[$X]),
        yRange: getRangeMinMax(columns[key]),
        len: columns.length,
        types: types[key]
      };
    }).filter(function (line) {
      return line;
    });

    if (stacked) {
      var filterY = res.map(function (d) {
        return d.y;
      });
      var getFirstYArray = filterY[0];
      var updatedArraysR = getStackedMinMax(filterY, getFirstYArray);
      var common = updatedArraysR.reduce(function (curr, next) {
        return curr.concat(next);
      }, []);
      var getMaxMin = getRangeMinMax(common);
      var updatedArrays = getStacked(getMaxMin.min, filterY, getFirstYArray, getMaxMin.max);
      var upd = filterY.map(function (_, id) {
        return _.map(function (o, i) {
          return updatedArrays[i][id].y1;
        });
      });
      res = res.map(function (item, i) {
        return { ...item,
          yDefault: item.y,
          y: upd[i],
          yRange: {
            max: getMaxMin.max,
            min: getMaxMin.min
          }
        };
      });
    }

    if (stacked && percentage) {
      var activeY = res.map(function (d) {
        return d.y;
      });
      var yS = activeY[0];

      var _updatedArraysR = getStackedMinMaxY(activeY, yS);

      var _common = _updatedArraysR.reduce(function (curr, next) {
        return curr.concat(next);
      }, []);

      var _getMaxMin = getRangeMinMax(_common);

      var _updatedArrays = getStackedPercantage(_getMaxMin.min, activeY, yS, _getMaxMin.max);

      var _upd = activeY.map(function (_, id) {
        return _.map(function (o, i) {
          return _updatedArrays[i][id].y1 + _updatedArrays[i][id].y0;
        });
      });

      res = res.map(function (item, i) {
        return { ...item,
          yDefault: item.y,
          y: _upd[i],
          yRange: {
            max: _getMaxMin.max,
            min: _getMaxMin.min
          }
        };
      });
    }

    return res;
  }

  function getStacked(min, root, points, max) {
    var cud = points.map(function (item) {
      return [];
    });
    points.forEach(function (lines, idx) {
      var y0 = 0;
      root.forEach(function (d, i) {
        cud[idx].push({
          y0: y0,
          y1: y0 + d[idx]
        });
        y0 = y0 + d[idx];
      });
    });
    return cud;
  }

  function getStackedPercantage(min, root, points, max) {
    var cud = points.map(function (item) {
      return [];
    });
    points.forEach(function (lines, idx) {
      var y0 = 0;
      root.forEach(function (d, i) {
        if (i === 0) {
          cud[idx].push({
            y0: 0,
            y1: 0
          });
          y0 = d[idx];
        } else if (i === root.length - 1) {
          cud[idx].push({
            y0: y0,
            y1: y0 - d[idx]
          });
        } else {
          cud[idx].push({
            y0: y0,
            y1: y0 + d[idx]
          });
          y0 = y0 + d[idx];
        }
      });
    });
    return cud;
  }

  function getStackedMinMax(root, points) {
    var cud = points.map(function (item) {
      return [];
    });
    points.forEach(function (lines, idx) {
      var y0 = 0;
      root.forEach(function (d, i) {
        cud[idx].push(y0 + d[idx]);
        y0 = y0 + d[idx];
      });
    });
    return cud.reverse();
  }

  function getStackedMinMaxY(root, points) {
    var cud = points.map(function (item) {
      return [];
    });
    points.forEach(function (lines, idx) {
      var y0 = 0;
      root.forEach(function (d, i) {
        cud[idx].push(y0 + d[idx]);
        y0 = y0 + d[idx];
      });
    });
    return cud;
  }

  function processCoords(w, h, ranges, lines, status) {
    var active = calculateChartRanges(lines, status);
    var res = {
      horizontal: null,
      vertical: {},
      data: null,
      barData: null,
      types: null
    };

    function concatObjValues(obj, type) {
      return Object.values(obj).reduce(function (curr, next) {
        // let values = next.map(item => item[type])
        return curr.concat(next[type]);
      }, []);
    }

    var merged = concatObjValues(active, 'y');
    var commonMinMax = getRangeMinMax(merged); // let rangeMerged = b;
    // console.log(commonMinMax)
    // let minMaxCommon = active

    res.data = active.map(function (line) {
      var _line$xRange = line.xRange,
          xMax = _line$xRange.max,
          xMin = _line$xRange.min;
      res.types = line.types;
      var yMax = commonMinMax.max;
      var yMin = commonMinMax.min;
      var xScale = scaleTime([0, w], [xMin, xMax]);
      var yScale = scaleLiniar([h, 0], [yMax, yMin]);
      var scaleLine = line.x.map(xScale);
      var scaleLineY = line.y.map(yScale);
      var xAxisTikers = line.x.map(convertMonthToString);

      if (ranges) {
        var _findRange = findRange(line.x.map(xScale), ranges),
            _findRange2 = _slicedToArray(_findRange, 2),
            rangeMin = _findRange2[0],
            rangeMax = _findRange2[1];

        xScale = scaleTime([0, w], [line.x[rangeMin], line.x[rangeMax - 1]]);
        var yMinRange = calculateCommonRange(active, rangeMin, rangeMax).min;
        var yMaxRange = calculateCommonRange(active, rangeMin, rangeMax).max;
        yScale = scaleLiniar([h, 0], [yMaxRange, yMinRange]);
        scaleLineY = line.y.map(yScale).map(function (item) {
          return Math.round(item);
        });
        scaleLine = line.x.map(xScale);
      }

      var xAxis = scaleLine.map(function (x, idx) {
        return {
          x: Math.round(x),
          tick: xAxisTikers[idx]
        };
      });
      var yAxis = scaleLineY.map(function (y, idx) {
        return {
          y: Math.round(y),
          tick: line.y[idx]
        };
      });
      var points = scaleLine.map(function (x, idx) {
        return [Math.round(x), Math.round(scaleLineY[idx])];
      });
      var upd = xAxis.map(function (item, idx) {
        return { ...item,
          y: yAxis[idx],
          value: line.x[idx],
          valueY: line.yDefault[idx],
          key: line.key,
          valueX: line.x[idx],
          idx: idx,
          name: line.name,
          color: line.color
        };
      });

      function generateAxisWithoutFilter(axis, w) {
        var amount = axis.map(function (o, idx) {
          return { ...o,
            idx: idx
          };
        }).filter(function (item, idx) {
          return item.x >= 0 && item.x <= w;
        });
        return amount;
      }

      var _generateAxis = generateAxis(xAxis, yAxis, w, h),
          horizontal = _generateAxis.horizontal;

      var currentRangeData = generateAxisWithoutFilter(upd, w);
      var vertical = generateYAxis(currentRangeData, h);
      res.horizontal = horizontal;
      res.vertical[line.key] = vertical;
      return { ...line,
        xCoords: scaleLine,
        yCoords: scaleLineY,
        xAxisTikers: xAxisTikers,
        xAxis: xAxis,
        yAxis: yAxis,
        horizontal: horizontal,
        vertical: vertical,
        points: points,
        currentRangeData: currentRangeData
      };
    });
    res.commonY = generateCommonYAxis(res.vertical, h);

    if (lines.percentage) {
      console.log(res);
    }

    if (!lines.percentage && lines.stacked) {
      return { ...res,
        data: res.data.reverse()
      };
    }

    return res;
  }
  /** CHART UTILS */


  function getRangeMinMax(arr) {
    return {
      max: Math.max.apply(null, arr),
      min: Math.min.apply(null, arr)
    };
  }

  function findRange(coords, _ref7) {
    var _ref8 = _slicedToArray(_ref7, 2),
        min = _ref8[0],
        max = _ref8[1];

    var minIndex = 0;
    var maxIndex = 0;
    var n = 0;
    var k = 0;

    while (min > coords[n]) {
      n += 1;
      minIndex = n;
      k = n;
    }

    while (max > coords[k]) {
      k += 1;
      maxIndex = k;
    }

    return [minIndex, maxIndex];
  }

  function calculateCommonRange(arr, rangeMin, rangeMax) {
    var getYs = arr.map(function (d) {
      return d.y.filter(function (_, idx) {
        return idx >= rangeMin && idx <= rangeMax;
      });
    });
    var concatYs = getYs.reduce(function (curr, next) {
      return curr.concat(next);
    }, []);
    var commonMinMax = getRangeMinMax(concatYs);
    return commonMinMax;
  }

  function concatObjValues(obj, type) {
    return Object.values(obj).reduce(function (curr, next) {
      var values = next.map(function (item) {
        return item[type];
      });
      return curr.concat(values);
    }, []);
  }

  function generateCommonYAxis(obj, height) {
    var common = concatObjValues(obj, 'tick');
    var getMaxMin = getRangeMinMax(common);
    var ticksValue = generateAxisY(getMaxMin.max, getMaxMin.min, height, 6);
    return ticksValue;
  }

  function generateYAxis(range, height) {
    var getYs = range.map(function (item) {
      return item.valueY;
    });
    var getMaxMin = getRangeMinMax(getYs);
    var ticksValue = generateTicks(getYs, getMaxMin);
    var tick = height / ticksValue.length;
    return ticksValue.map(function (item, idx) {
      return {
        y: tick * idx,
        tick: Math.round(item)
      };
    });
  }

  function generateTicks(getYs, getMaxMin) {
    var amount = getYs.length;
    var MAX_IN_ARRAY = 4;
    var filtered = amount / MAX_IN_ARRAY;
    var eachSix = getYs.filter(function (idm, id) {
      return id % Math.round(filtered) === 0;
    }).slice(0, MAX_IN_ARRAY);
    eachSix.unshift(getMaxMin.min);
    eachSix.push(getMaxMin.max);
    return eachSix;
  }

  function generateAxis(axisX, axisY, width, height) {
    // Add index
    var axisXwithId = axisX.map(function (o, idx) {
      return { ...o,
        idx: idx
      };
    });
    var curr = axisXwithId.filter(function (item, idx) {
      return item.x >= 0 && item.x <= width;
    });
    var amount = curr.length;
    var MAX_IN_ARRAY = 6;
    var filtered = amount / MAX_IN_ARRAY;
    var ar = axisXwithId.filter(function (idm, id) {
      return id % Math.round(filtered) === 0;
    });
    var updated = ar.filter(function (item, idx) {
      return item.x >= 0;
    }).slice(0, 6);
    return {
      horizontal: updated
    };
  }

  function generateAxisY(max, min, layoutMax, maxInLine) {
    var diff = max - min;
    var tick = layoutMax / maxInLine;
    var t = diff / (maxInLine - 1);
    var generateTicks = Array.from({
      length: maxInLine
    }, function (o, idx) {
      if (idx === 0) {
        return min;
      }

      if (idx === maxInLine - 1) {
        return max;
      }

      return min + t * idx;
    });
    return generateTicks.reverse().map(function (value, idx) {
      return {
        y: tick * idx,
        tick: Math.round(value)
      };
    });
  }
  /** CHART UTILS END */


  function createTick(wrapper, axis, w) {
    var xmlns = 'http://www.w3.org/2000/svg';
    var text = document.createElementNS(xmlns, 'text');
    var line = document.createElementNS(xmlns, 'line');
    setAttrNs(text, [{
      y: "0"
    }, {
      dy: "0.71em"
    }, {
      style: "fill: #".concat(wrapper.dataset.axisColor, ";")
    }]);
    setAttrNs(line, [{
      class: 'y-line-tick axis-line'
    }, {
      x1: wrapper.dataset.axisKey === 'y1' ? 40 : 0
    }, {
      y1: 24
    }, {
      x2: wrapper.dataset.axisKey === 'y1' ? -w : w
    }, {
      y2: 24
    }]);
    var tickWrapper = document.createElementNS(xmlns, 'g');
    var transform = axis === 'x' ? "translate(".concat(0, ", 0)") : "translate(0, ".concat(0, ")");
    setAttrNs(tickWrapper, [{
      class: "tick-".concat(axis, " axis-line")
    }, {
      transform: transform
    }]);
    tickWrapper.appendChild(text);

    if (axis === 'y') {
      tickWrapper.appendChild(line);
    }

    return tickWrapper;
  }

  function setupDefaultButtonColor(btn, color) {
    btn.style.backgroundColor = "#".concat(color);
    btn.style.color = "#FFF";
    btn.style.borderColor = "transparent";
  } // let Tooltip = TooltipInit.bind(ChartRoot)

  /** CANVAS DRAW SHAPE */


  function drawLine(cx, data, color, height) {
    var diff = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
    cx.strokeStyle = color;
    cx.beginPath();
    cx.moveTo(0, height);

    for (var i = 0; i < data.length; i += 1) {
      var _data$i = _slicedToArray(data[i], 2),
          x = _data$i[0],
          yInitial = _data$i[1];

      var updX = x - diff;
      cx.lineTo(updX, yInitial);
    }

    cx.stroke();
  }

  function barRect(cx, data, color, height, diffWidth) {
    var width = Math.round(diffWidth);
    cx.beginPath();
    cx.fillStyle = color;
    data.forEach(function (item, idx) {
      var baseY = height;

      var _item = _slicedToArray(item, 2),
          x = _item[0],
          y = _item[1];

      if (x > 0 && x < 500) {
        cx.moveTo(x, baseY);
        cx.lineTo(x, y);
        cx.lineTo(x + width, y);
        cx.lineTo(x + width, baseY);
      }
    });
    cx.fill();
  }

  function drawArea(cx, data, color, height) {
    cx.fillStyle = color;
    cx.beginPath();
    cx.moveTo(0, 0);

    for (var i = 0; i < data.length; i += 1) {
      var _data$i2 = _slicedToArray(data[i], 2),
          x = _data$i2[0],
          y = _data$i2[1];

      cx.lineTo(x, y);

      if (i === data.length - 1) {
        cx.lineTo(x, 0);
      }
    }

    cx.fill();
  }
  /** CANVAS DRAW SHAPE END */

  /** HELPERS */


  function convertMonthToString(date) {
    var current = new Date(date);
    var day = current.getDate();
    var month = current.getMonth();
    return "".concat(day, " ").concat(MONTHES[month]);
  }

  var normilizeColumns = function normilizeColumns(columns) {
    return columns.reduce(function (curr, _ref9) {
      var _ref10 = _toArray(_ref9),
          key = _ref10[0],
          values = _ref10.slice(1);

      return _defineProperty({ ...curr
      }, key, values);
    }, {});
  };

  function normilizeData(data) {
    return Object.assign({}, data, {
      columns: normilizeColumns(data.columns)
    });
  }

  function setAttrNs(el, values) {
    var entries = values.map(function (item) {
      return Object.entries(item);
    });
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = entries[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var _step$value = _slicedToArray(_step.value, 1),
            i = _step$value[0];

        el.setAttributeNS(null, i[0], i[1]);
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return != null) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    return el;
  }

  function qs(element) {
    return document.querySelector(element);
  }

  function getFullDate(value, isFullMonthView) {
    var initial = new Date(value);
    var date = initial.getDate();
    var day = initial.getDay();
    var month = initial.getMonth();
    var year = initial.getFullYear();

    if (isFullMonthView) {
      return "".concat(date, " ").concat(MONTHES_FULL[month], " ").concat(year);
    }

    return "".concat(DAYS[day].slice(0, 3), ", ").concat(MONTHES[month], " ").concat(date, " ").concat(year);
  }
  /** HELPERS END */

  /** SCALES */


  function scaleLiniar(_ref12, _ref13) {
    var _ref14 = _slicedToArray(_ref12, 2),
        min = _ref14[0],
        max = _ref14[1];

    var _ref15 = _slicedToArray(_ref13, 2),
        axisMin = _ref15[0],
        axisMax = _ref15[1];

    return function (val) {
      var diffCanvas = max - min;
      var diffAxis = axisMax - axisMin;
      var diff = (val - axisMin) / diffAxis;
      var res = diff * diffCanvas;
      return Math.abs(res);
    };
  }

  function scaleTime(_ref16, _ref17) {
    var _ref18 = _slicedToArray(_ref16, 2),
        min = _ref18[0],
        max = _ref18[1];

    var _ref19 = _slicedToArray(_ref17, 2),
        dateMin = _ref19[0],
        dateMax = _ref19[1];

    var DAY = 1000 * 60 * 60 * 24;
    var maxDate = new Date(dateMax).getTime();
    var minDate = new Date(dateMin).getTime();
    var totalPeriod = (maxDate - minDate) / DAY;
    var diffCanvas = max - min;
    return function (val) {
      var current = new Date(val).getTime();
      var time = (current - minDate) / DAY;
      var step = time * 100 / totalPeriod;
      var diff = diffCanvas * (step / 100);
      return min + diff;
    };
  }
  /** SCALES END */

  /** TEMPLATES */


  function Button(key, name, color) {
    return "\n        <button \n          class=\"toggle-btn pulse\" \n          style=\"color: ".concat("#fff", ";background-color: #", color, ";border: 1px solid transparent\" \n          data-toggle-btn=\"").concat(key, "\" data-color=\"").concat(color, "\">\n          <div class=\"target icon off\">\n          <div class=\"dot\"></div>\n        </div>\n        ").concat(name, "\n        </button>\n      ");
  }

  function AxisLines(names, w, pallet) {
    var lines = "";
    var b = names;
    Object.keys(names).forEach(function (item, idx) {
      var btnColor = pallet[b[item]].btn;
      lines += "<g class=\"tick-wrapper-y\" data-axis-key=\"".concat(item, "\" data-axis-color=\"").concat(btnColor, "\" transform=\"translate(").concat(idx === 0 ? 0 : w - 20, ", 10)\"></g>");
    });
    return lines;
  }

  var Magnifier =
  /*#__PURE__*/
  function () {
    function Magnifier(wrapper, cb, interacted, range) {
      _classCallCheck(this, Magnifier);

      this.wrapper = wrapper;
      this.el = wrapper.querySelector('.minimap-thumb');
      this.interacted = interacted;
      this.range = range;
      this.controlLeft = this.el.querySelector('.left');
      this.controlRight = this.el.querySelector('.right');
      this.shadowLeft = this.wrapper.querySelector('.magnifier_shadow.left');
      this.shadowRight = this.wrapper.querySelector('.magnifier_shadow.right');
      this.actionResize = cb;
      this.handleWidth = 9;
      this.resizeStart = this.resizeStart.bind(this);
    }

    _createClass(Magnifier, [{
      key: "init",
      value: function init() {
        this.el.addEventListener('mousedown', this.resizeStart);
        this.el.addEventListener('touchstart', this.resizeStart);
        this.initDefault();
      }
    }, {
      key: "initDefault",
      value: function initDefault() {
        var _this$range = _slicedToArray(this.range, 2),
            xMin = _this$range[0],
            xMax = _this$range[1];

        var width = xMax - xMin + this.handleWidth;
        var rightOffset = this.wrapper.offsetWidth - width - this.handleWidth;
        this.el.style.left = "".concat(this.handleWidth + xMin, "px");
        this.el.style.right = "".concat(xMin, "px");
        this.el.style.width = "".concat(width, "px");
        this.shadowLeft.style.width = xMin + 'px';
        this.shadowRight.style.width = rightOffset + 'px';
      }
    }, {
      key: "resizeLeft",
      value: function resizeLeft(width, resize) {
        var _this3 = this;

        this.el.style.width = width + 'px';
        this.el.style.left = "".concat(resize, "px");
        this.shadowLeft.style.width = resize + 'px';
        setTimeout(function () {
          _this3.actionResize.update(resize, width + resize, _this3.interacted);
        }, 0);
      }
    }, {
      key: "resizeRight",
      value: function resizeRight(width, left, shadow, axis) {
        var _this4 = this;

        this.el.style.width = "".concat(width, "px");
        this.shadowRight.style.width = shadow + 'px';
        setTimeout(function () {
          _this4.actionResize.update(left, axis, _this4.interacted);
        }, 0);
      }
    }, {
      key: "dragCenter",
      value: function dragCenter(l, r, width) {
        var _this5 = this;

        this.el.style.left = l + 'px';
        this.shadowLeft.style.width = l + 'px';
        this.shadowRight.style.width = r + 'px';
        setTimeout(function () {
          _this5.actionResize.update(l, l + width, _this5.interacted);
        }, 0);
      }
    }, {
      key: "resizeStart",
      value: function resizeStart(e) {
        var _this6 = this;

        this.touchInit = true;
        var side = e.target.dataset.thumbSide;
        var width = this.el.offsetWidth;
        var offset = this.el.offsetLeft;
        var containerWidth = this.wrapper.offsetWidth;
        var handlersWidth = 8;
        var pageX = e.pageX;
        document.body.style.userSelect = 'none';

        if (e.type === 'touchstart') {
          pageX = e.touches[0].pageX;
        }

        var resize = function resize(ec) {
          var resizePageX = ec.pageX;

          if (ec.type === 'touchmove') {
            resizePageX = ec.touches[0].pageX;
          }

          var moveX = resizePageX - pageX;

          if (Math.abs(moveX) < 3) {
            return;
          }

          var elW = width + (resizePageX - pageX);
          var l = offset + (resizePageX - pageX);
          var r = containerWidth - (l + width);
          var maxLeft = l - handlersWidth * 2;
          var maxRight = r + handlersWidth;
          var mR = offset + handlersWidth + elW;
          var shD = containerWidth - (elW + offset);

          if (side === 'right') {
            if (maxRight >= 0 && containerWidth - mR > 0 && elW > 30) {
              _this6.resizeRight(elW, offset, shD, mR);
            }
          }

          var wwC = width + (offset - maxLeft);
          var finishLeft = containerWidth - (wwC + maxLeft) + wwC + handlersWidth;

          if (side === 'left') {
            if (finishLeft < containerWidth && wwC > 30) {
              _this6.resizeLeft(wwC, maxLeft);
            }
          }

          if (side === 'center') {
            if (l > handlersWidth && containerWidth - mR > 0) {
              _this6.dragCenter(l, r, width);
            }
          }
        };

        document.addEventListener('mousemove', resize);
        document.addEventListener('touchmove', resize);
        document.addEventListener('mouseup', function (e) {
          _this6.touchInit = false;
          document.body.style.userSelect = 'auto';
          document.removeEventListener('mousemove', resize);
        }, false);
        document.addEventListener('touchend', function (e) {
          _this6.touchInit = false;
          document.body.style.userSelect = 'auto';
          document.removeEventListener('touchmove', resize);
        }, false);
      }
    }]);

    return Magnifier;
  }();

  function ChartTemplate(name, chart, _ref20) {
    var w = _ref20.w,
        h = _ref20.h,
        mW = _ref20.mW,
        mH = _ref20.mH,
        colors = _ref20.colors,
        pallet = _ref20.pallet,
        title = _ref20.title;
    var lines = chart.y_scaled ? AxisLines(chart.names, w, pallet) : "<g class=\"tick-wrapper-y\" transform=\"translate(5, 10)\"></g>"; // <rect x="50" y="10" fill="red" width="10" height="250" opacity=".1"></rect>

    var temp = "\n      <div class=\"chart-header ".concat(name, "\">\n      <h3>").concat(title, "</h3>\n      <div class=\"dates-range\"></div>\n      </div>\n    </div>\n        <div id=\"").concat(name, "\" class=\"chart-wrapper\" data-color-theme=\"").concat(colors, "\">\n        <canvas class=\"chart\" id=\"graph\" width=\"").concat(w, "\" height=\"").concat(h, "\"></canvas>\n        <svg class=\"chart-axises\" id=\"graph-axis\" preserveAspectRatio=\"xMinYMax\" width=\"").concat(w, "\" height=\"").concat(h, "\" viewBox=\"0 0 ").concat(w, " ").concat(h, "\">\n        ").concat(lines, "\n        <line class=\"tooltip-line\" y1=\"0\" y2=\"250\" opacity=\"0\" strokeWidth=\"2\"></line>\n        </svg>\n        <svg class=\"chart-axises-x\" width=\"").concat(w, "\" height=\"30\">\n          <g class=\"tick-wrapper-x\" transform=\"translate(5, 5)\"></g>\n        </svg>\n        <div class=\"minimap\">\n            <canvas class=\"minimap-chart\" id=\"graph-minimap\" width=\"").concat(mW, "\" height=\"").concat(mH, "\">\n            </canvas>\n            <div class=\"magnifier\">\n                <div class=\"magnifier_shadow scroll-background left\"></div>\n                <div class=\"magnifier_shadow scroll-background right\"></div>\n    \n                <div class=\"magnifier__thumb minimap-thumb\" data-thumb-side=\"center\">\n                    <div class=\"minimap-thumb__control scroll-selector right\" data-thumb-side=\"right\"></div>\n                    <div class=\"minimap-thumb__control scroll-selector left\" data-thumb-side=\"left\"></div>\n                </div>\n            </div>\n        </div>\n        <div class=\"chart-contols\">\n        </div>\n      </div>\n      ");
    return temp;
  }
  /** TEMPLATES END */


  chart.init();
})();